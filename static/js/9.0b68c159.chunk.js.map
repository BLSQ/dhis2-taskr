{"version":3,"sources":["leaflet/CoordinatesControl.js","OrgunitMap.js"],"names":["L","Control","MousePosition","extend","_pos","options","position","separator","emptyString","lngFirst","numDigits","lngFormatter","undefined","latFormatter","formatter","prefix","wrapLng","onAdd","map","this","_container","DomUtil","create","DomEvent","disableClickPropagation","on","_onMouseMove","innerHTML","onRemove","off","getLatLng","e","latlng","wrap","lng","lat","value","prefixAndValue","lngValue","latValue","Util","formatNum","Map","mergeOptions","positionControl","addInitHook","addControl","control","mousePosition","CoordinatesControl","MapControl","constructor","props","super","createLeafletElement","addTo","leaflet","withLeaflet","getCircularReplacer","seen","WeakSet","key","has","add","shapesFeatureType","maps","name","attribution","url","isString","r","getRandomColor","color","i","Math","floor","random","OrgunitMap","lines","showableMap","width","height","showLayers","status","setStatus","useState","clicked","setClicked","selectedLayer","setSelectedLayer","rawPoints","setRawPoints","React","pointMarkers","setPointMarkers","rawGeojsons","setRawGeojsons","mapRef","useRef","handleClick","current","bound","leafletElement","length","points","result","Infinity","point","coord","bboxForPoints","southWest","northEast","bounds","fitBounds","myTurf","turf","functionPoly","bbox","bboxPolygon","featureCollection","feature","useEffect","setTimeout","event","document","getElementsByClassName","style","zIndex","throttle","originalEvent","currentTarget","target","nextTarget","nodeName","toLowerCase","classList","indexOf","ev","MouseEvent","type","dispatchEvent","_stopped","stop","newRawPoints","filter","l","coordinates","coordinate","geometry","latitude","longitude","startsWith","newGeojsons","includes","line","JSON","parse","ignored","properties","g","markers","index","latlong","reverse","slice","id","iconColor","tooltip","renderToString","Object","keys","k","AsPrimitive","customIcon","geojsons","opacity","fillColor","weight","fillOpacity","dashArray","GeoJSON","data","title","stringify","onClick","removed","node","pointerEvents","elementFromPoint","clientX","clientY","onFeature","className","display","FormControl","InputLabel","Select","onChange","val","m","MenuItem","Button","preferCanvas","doubleClickZoom","center","zoom","ref","padding","TileLayer","interactive"],"mappings":"gRAGAA,IAAEC,QAAQC,cAAgBF,IAAEC,QAAQE,OAAO,CACzCC,KAAM,KAENC,QAAS,CACPC,SAAU,aACVC,UAAW,MACXC,YAAa,cACbC,UAAU,EACVC,UAAW,EACXC,kBAAcC,EACdC,kBAAcD,EACdE,eAAWF,EACXG,OAAQ,GACRC,SAAS,GAGXC,MAAO,SAASC,GAKd,OAJAC,KAAKC,WAAapB,IAAEqB,QAAQC,OAAO,MAAO,iCAC1CtB,IAAEuB,SAASC,wBAAwBL,KAAKC,YACxCF,EAAIO,GAAG,YAAaN,KAAKO,aAAcP,MACvCA,KAAKC,WAAWO,UAAYR,KAAKd,QAAQG,YAClCW,KAAKC,YAGdQ,SAAU,SAASV,GACjBA,EAAIW,IAAI,YAAaV,KAAKO,eAG5BI,UAAW,WACT,OAAOX,KAAKf,MAGdsB,aAAc,SAASK,GACrBZ,KAAKf,KAAO2B,EAAEC,OAAOC,OACrB,IAEIC,EACAC,EACAC,EACAC,EALAC,EAAWnB,KAAKd,QAAQW,QAAUe,EAAEC,OAAOC,OAAOC,IAAMH,EAAEC,OAAOE,IACjEK,EAAWR,EAAEC,OAAOG,IAMpBhB,KAAKd,QAAQS,UACfuB,EAAiBlB,KAAKd,QAAQS,UAAUwB,EAAUC,IAElDL,EAAMf,KAAKd,QAAQM,aACfQ,KAAKd,QAAQM,aAAa2B,GAC1BtC,IAAEwC,KAAKC,UAAUH,EAAUnB,KAAKd,QAAQK,WAC5CyB,EAAMhB,KAAKd,QAAQQ,aACfM,KAAKd,QAAQQ,aAAa0B,GAC1BvC,IAAEwC,KAAKC,UAAUF,EAAUpB,KAAKd,QAAQK,WAC5C0B,EAAQjB,KAAKd,QAAQI,SACjByB,EAAMf,KAAKd,QAAQE,UAAY4B,EAC/BA,EAAMhB,KAAKd,QAAQE,UAAY2B,EACnCG,EAAiBlB,KAAKd,QAAQU,OAAS,IAAMqB,GAG/CjB,KAAKC,WAAWO,UAAYU,KAIhCrC,IAAE0C,IAAIC,aAAa,CACjBC,iBAAiB,IAGnB5C,IAAE0C,IAAIG,aAAY,WACZ1B,KAAKd,QAAQuC,kBACfzB,KAAKyB,gBAAkB,IAAI5C,IAAEC,QAAQC,cACrCiB,KAAK2B,WAAW3B,KAAKyB,qBAIzB5C,IAAE+C,QAAQC,cAAgB,SAAS3C,GACjC,OAAO,IAAIL,IAAEC,QAAQC,cAAcG,IAGrC,MAAM4C,UAA2BC,IAG/BC,YAAYC,GACVC,MAAMD,GAGRE,qBAAqBF,GAEnB,OADAjC,KAAK4B,QAAU/C,IAAE+C,QAAQC,gBAAgBO,MAAMH,EAAMI,QAAQtC,KACtDC,KAAK4B,SAIDU,kBAAYR,G,oDC5E3B,MAAMS,EAAsB,KAC1B,MAAMC,EAAO,IAAIC,QACjB,MAAO,CAACC,EAAKzB,KACX,GAAqB,kBAAVA,GAAgC,OAAVA,EAAgB,CAC/C,GAAIuB,EAAKG,IAAI1B,GACX,OAEFuB,EAAKI,IAAI3B,GAEX,OAAOA,IAIL4B,EAAoB,CAAC,aAAc,UAAW,gBAE9CC,EAAO,CACX,CACEC,KAAM,6BACNC,YAAa,gDACbC,IACE,2GAEJ,CACEF,KAAM,2BACNC,YAAa,gDACbC,IACE,0GAEJ,CACEF,KAAM,wBACNC,YAAc,uQACdC,IAAK,mEAEP,CACEF,KAAM,8BACNE,IAAK,uEACLD,YACE,6NAEJ,CACED,KAAM,yBACNE,IAAK,oDACLD,YAAa,WAyBjB,SAASE,EAASC,GAChB,MAAmB,iBAALA,EAEhB,SAASC,IAGP,IAFA,IACIC,EAAQ,IACHC,EAAI,EAAGA,EAAI,EAAGA,IACrBD,GAHY,mBAGKE,KAAKC,MAAsB,GAAhBD,KAAKE,WAEnC,OAAOJ,EAwXMK,UArXf,UAAoB,MAClBC,EADkB,SAElBxE,EAFkB,YAGlByE,EAHkB,MAIlBC,EAJkB,OAKlBC,EALkB,WAMlBC,IAEA,MAAOC,EAAQC,GAAaC,mBAAS,KAC9BC,EAASC,GAAcF,mBAAS,KAChCG,EAAeC,GAAoBJ,mBAASpB,EAAK,KACjDyB,EAAWC,GAAgBC,IAAMP,cAASzE,IAC1CiF,EAAcC,GAAmBF,IAAMP,cAASzE,IAChDmF,EAAaC,GAAkBJ,IAAMP,cAASzE,GAC/CqF,EAASC,iBAAO,MAChBC,EAAc,KAClB,GAAIF,GAAUA,EAAOG,QAAS,CAC5B,IAAIC,EACJ,MAAMnF,EAAM+E,EAAOG,QAAQE,eAC3B,GAAIT,GAAgBA,EAAaU,OAAS,EAAG,CAE3CF,EAtDeG,KACrB,MAAMC,EAAS,CAACC,IAAUA,KAAU,KAAW,KAC/C,IAAK,IAAIC,KAASH,EAAQ,CACxB,IAAII,EAAQD,EAAMrG,SACdmG,EAAO,GAAKG,EAAM,KACpBH,EAAO,GAAKG,EAAM,IAEhBH,EAAO,GAAKG,EAAM,KACpBH,EAAO,GAAKG,EAAM,IAEhBH,EAAO,GAAKG,EAAM,KACpBH,EAAO,GAAKG,EAAM,IAEhBH,EAAO,GAAKG,EAAM,KACpBH,EAAO,GAAKG,EAAM,IAItB,OAAOH,GAmCYI,CAAchB,GAI7B,GAAIQ,GAASA,EAAM,KAAOK,IAAU,CAClC,MAAMI,EAAY9G,SAASqG,EAAM,GAAIA,EAAM,IACrCU,EAAY/G,SAASqG,EAAM,GAAIA,EAAM,IACrCW,EAAShH,eAAe8G,EAAWC,GACzC7F,EAAI+F,UAAUD,QACT,GAAIjB,GAAeA,EAAYQ,OAAS,EAAG,CAEhD,MAAMW,EAASC,EACTC,EAAeF,EAAOG,KAG5B,IAAIC,EACJ,IACEA,EAAcF,EACZF,EAAOK,kBAAkBxB,EAAY7E,KAAKoD,GAAM4C,EAAOM,QAAQlD,OAEjE,MAAOvC,GAEPuF,EAAcF,EAAarB,EAAY,IAGzC,GAAIuB,EAAa,CACf,MAAMR,EAAY9G,SAASsH,EAAY,GAAIA,EAAY,IACjDP,EAAY/G,SAASsH,EAAY,GAAIA,EAAY,IACjDN,EAAShH,eAAe8G,EAAWC,GAEzC7F,EAAI+F,UAAUD,OAqKtB,GAhKAS,qBAAU,KACRC,YAAW,KACTvB,MACC,OACF,CAACF,EAAQJ,EAAcE,IAE1B0B,qBAAU,KACR,GAAIxB,GAAUA,EAAOG,SAAWH,EAAOG,QAAQE,eAAgB,CAC7D,MAAMpF,EAAM+E,EAAOG,QAAQE,eAC3BpF,EAAIO,GAAG,SAAS,SAASkG,GACNC,SAASC,uBACxB,wBACA,GACSC,MAAMC,QAAU,KAE7B7G,EAAIO,GACF,YACAzB,OAAOgI,UAAS,SAASL,GACvB,GAAIA,EAAMM,cAAe,CAEvB,IAAIC,EAAgBP,EAAMM,cAAcE,OAIxC,IAAIC,EAAaR,SAASC,uBACxB,wBACA,GASF,GACEO,GACsC,SAAtCA,EAAWC,SAASC,gBACyC,IAA7DF,EAAWG,UAAUnG,MAAMoG,QAAQ,sBACnCN,IAAkBE,EAClB,CACA,IAAIK,EAAK,IAAIC,WAAWf,EAAMgB,KAAMhB,EAAMM,eAC1CG,EAAWN,MAAMC,OAAS,MAEfK,EAAWQ,cAAcH,IACrBA,EAAGI,WAChB7I,WAAW8I,KAAKnB,OAIrB,QAGN,CAAC1B,IACJwB,qBAAU,KACR,QAAa7G,GAATkE,EACF,OAEF,MAAMiE,EAAejE,EAAMkE,QAAQC,IACjC,QAASrI,GAALqI,EACF,OAAO,EAET,QACoBrI,IAAlBqI,EAAEC,kBACetI,IAAjBqI,EAAEE,iBACavI,IAAfqI,EAAEG,SAEF,OAAO,EAIT,SADEH,EAAEE,YAAcF,EAAEE,WAAWE,UAAYJ,EAAEE,WAAWG,gBAIpDL,EAAEG,UAA+B,SAAnBH,EAAEG,SAAST,YAGP/H,IAAlBqI,EAAEC,cAIJ7E,EAAS4E,EAAEC,eACVD,EAAEC,YAAYK,WAAW,OACT,IAAjBN,EAAEC,iBAIAM,EAAc1E,EACjBkE,QACEC,GACEA,EAAEC,aACD7E,EAAS4E,EAAEC,cACXD,EAAEC,YAAYK,WAAW,OAC1BN,EAAEG,UACDH,EAAEG,SAAST,MACX3E,EAAkByF,SAASR,EAAEG,SAAST,QAE3CzH,KAAKwI,IACJ,IAAIN,EAAWM,EAAKN,SACpB,IACEA,EAAWjC,UAAawC,KAAKC,MAAMF,EAAKR,cACxC,MAAOW,GACP,IACET,EAAWjC,eAAkBwC,KAAKC,MAAMF,EAAKR,cAC7C,MAAOW,KAUX,OARIT,SACyBxI,GAAvBwI,EAASU,aACXV,EAASU,WAAa,IAEpBV,EAASU,aACXV,EAASU,WAAWJ,KAAOA,IAGxBN,KAERJ,QAAQe,GAAMA,IAEXC,EAAUjB,EAAa7H,KAAI,CAACwI,EAAMO,KACtC,MAAMC,EACJR,EAAKP,YAAcO,EAAKP,WAAWE,UAAYK,EAAKP,WAAWG,UAC3D,CAACI,EAAKP,WAAWE,SAAUK,EAAKP,WAAWG,WAC3CI,EAAKR,YACLS,KAAKC,MAAMF,EAAKR,aAAaiB,UAC7BT,EAAKN,UAAYM,EAAKN,SAASF,YAAYkB,MAAM,GAAGD,UACpD3F,EAAQkF,EAAKlF,OAAS,MAC5B,MAAO,CACL6F,GAAI,SAAWJ,EACfpG,IAAK,SAAWoG,EAChBK,UAAW9F,EACXlE,SAAU4J,EACVK,QAAS,IACAC,yBACL,8BACGC,OAAOC,KAAKhB,GAAMxI,KAAKyJ,GAEpB,gCACE,4BAAIA,IADN,IACa,cAACC,EAAA,EAAD,CAAaxI,MAAOsH,EAAKiB,aAQhDE,WACE,iDACArG,EACA,gFACAA,EACA,4BACAA,EACA,iBAGNsB,EAAgBkE,GAChBhE,EAAewD,GACf7D,EAAaoD,GACb5C,MACC,CAACrB,SACSlE,GAATkE,GAA+B,MAATA,EACxB,OAAO,6BAGT,IAAKC,EACH,OACE,wGAiDJ,MAAM+F,OACWlK,GAAfmF,EACI,GACAA,EACGiD,QACEI,GACCA,GAAYA,EAASU,YAAcV,EAASU,WAAWJ,OAE1DxI,KAAI,CAACkI,EAAUa,KACd,MAAMP,EAAON,EAASU,WAAWJ,KAC3BqB,EAA2B,cAAjB3B,EAAST,KAAuB,EAAI,GACpDe,EAAKsB,UAAYtB,EAAKsB,WAAazG,IACnC,MAAMuD,EAAQ,CACZkD,UAAWtB,EAAKsB,UAChBxG,MAAOkF,EAAKlF,OAASD,IACrB0G,OAAQvB,EAAKqB,SAAWA,EACxBA,QAASrB,EAAKqB,SAAWA,EACzBG,YAAaxB,EAAKqB,SAAWA,GAO/B,OALIzF,GAAWoE,IACb5B,EAAMmD,OAAS,EACfnD,EAAMiD,QAAU,GAChBjD,EAAMqD,UAAY,OAGlB,cAACC,EAAA,EAAD,CACEC,KAAMjC,EAENtB,MAAOA,EACPwD,MAAO3B,KAAK4B,UAAU7B,EAAMhG,KAC5B8H,QAAU7D,KAzExB,SAAmBH,EAASG,GAC1B,GAAIA,EAAMM,cAAcY,SACtB,OAIF,IAEI4C,EAFAvD,EAAgBP,EAAMM,cAAcE,OAKxCsD,EAAU,CACRC,KAAMxD,EACNyD,cAAezD,EAAcJ,MAAM6D,eAErCzD,EAAcJ,MAAM6D,cAAgB,OAGpC,IAAIvD,EAAaR,SAASgE,iBACxBjE,EAAMM,cAAc4D,QACpBlE,EAAMM,cAAc6D,SAMtB,GACE1D,GACsC,SAAtCA,EAAWC,SAASC,gBACyC,IAA7DF,EAAWG,UAAUnG,MAAMoG,QAAQ,qBACnC,CACA,IAAIC,EAAK,IAAIC,WAAWf,EAAMM,cAAcU,KAAMhB,EAAMM,iBAC7CG,EAAWQ,cAAcH,IACrBA,EAAGI,WAChB7I,WAAW8I,KAAKnB,GAKpB8D,EAAQC,KAAK5D,MAAM6D,cAAgBF,EAAQE,cAC3CpG,EAAWiC,GAkCGuE,CAAUrC,EAAM/B,KAJb,UAAYsC,GAAS3E,GAAWoE,EAAO,UAAY,YActE,OACE,sBAAKsC,UAAU,mBAAf,UACE,4BAAI7G,IACHD,GACC,sBACE4C,MAAO,CACLmE,QAAS,QAFb,UAKE,eAACC,EAAA,EAAD,WACE,cAACC,EAAA,EAAD,oBACA,cAACC,EAAA,EAAD,CAAQC,SAfE,CAAC1E,EAAO2E,KAC1B7G,EAAiB6G,EAAIlJ,MAAMhB,QAcYA,MAAOoD,EAAtC,SACGvB,EAAK/C,KAAKqL,GACT,cAACC,EAAA,EAAD,CAAUpK,MAAOmK,EAAjB,SAAqBA,EAAErI,cAI7B,cAACuI,EAAA,EAAD,CAAQjB,QAASrF,EAAjB,oBAGJ,gCACGrB,EAAMyB,OADT,aAC2Bb,EAAYA,EAAUa,OAAS,IAD1D,sBAEcuE,EAASvE,OAFvB,oBAEgD,IAC7CjB,GACCmF,OAAOC,KAAKpF,GACT0D,QAAQ2B,IAAO,CAAC,WAAY,eAAelB,SAASkB,KACpDzJ,KAAKyJ,GAEF,gCACE,4BAAIA,IADN,IACa,cAACC,EAAA,EAAD,CAAaxI,MAAOkD,EAAQqF,cAMhD9E,GAAgBA,EAAa,IAAQiF,GAAYA,EAAS,KAC3D,eAACpI,EAAA,EAAD,CACEgK,cAAc,EACdC,iBAAiB,EACjBC,OAAQtM,EACRuM,KAAM,EACNC,IAAK7G,EACL6B,MAAO,CACL9C,MAAOA,GAAS,MAChBC,OAAQA,GAAU,QAClB8H,QAAS,OATb,UAYE,cAACC,EAAA,EAAD,IAAexH,IACf,cAAC,EAAD,CAAoBlF,SAAS,MAAM4I,YAAY,YAE9C4B,EAEAjF,GAAgBA,EAAa,IAC5B,cAAC,IAAD,CAAqBmE,QAASnE,EAAcoH,aAAa,GAAxC","file":"static/js/9.0b68c159.chunk.js","sourcesContent":["import L from \"leaflet\";\nimport { withLeaflet, MapControl } from \"react-leaflet\";\n\nL.Control.MousePosition = L.Control.extend({\n  _pos: null,\n\n  options: {\n    position: \"bottomleft\",\n    separator: \" : \",\n    emptyString: \"Unavailable\",\n    lngFirst: false,\n    numDigits: 5,\n    lngFormatter: undefined,\n    latFormatter: undefined,\n    formatter: undefined,\n    prefix: \"\",\n    wrapLng: true\n  },\n\n  onAdd: function(map) {\n    this._container = L.DomUtil.create(\"div\", \"leaflet-control-mouseposition\");\n    L.DomEvent.disableClickPropagation(this._container);\n    map.on(\"mousemove\", this._onMouseMove, this);\n    this._container.innerHTML = this.options.emptyString;\n    return this._container;\n  },\n\n  onRemove: function(map) {\n    map.off(\"mousemove\", this._onMouseMove);\n  },\n\n  getLatLng: function() {\n    return this._pos;\n  },\n\n  _onMouseMove: function(e) {\n    this._pos = e.latlng.wrap();\n    var lngValue = this.options.wrapLng ? e.latlng.wrap().lng : e.latlng.lng;\n    var latValue = e.latlng.lat;\n    var lng;\n    var lat;\n    var value;\n    var prefixAndValue;\n\n    if (this.options.formatter) {\n      prefixAndValue = this.options.formatter(lngValue, latValue);\n    } else {\n      lng = this.options.lngFormatter\n        ? this.options.lngFormatter(lngValue)\n        : L.Util.formatNum(lngValue, this.options.numDigits);\n      lat = this.options.latFormatter\n        ? this.options.latFormatter(latValue)\n        : L.Util.formatNum(latValue, this.options.numDigits);\n      value = this.options.lngFirst\n        ? lng + this.options.separator + lat\n        : lat + this.options.separator + lng;\n      prefixAndValue = this.options.prefix + \" \" + value;\n    }\n\n    this._container.innerHTML = prefixAndValue;\n  }\n});\n\nL.Map.mergeOptions({\n  positionControl: false\n});\n\nL.Map.addInitHook(function() {\n  if (this.options.positionControl) {\n    this.positionControl = new L.Control.MousePosition();\n    this.addControl(this.positionControl);\n  }\n});\n\nL.control.mousePosition = function(options) {\n  return new L.Control.MousePosition(options);\n};\n\nclass CoordinatesControl extends MapControl {\n  control;\n\n  constructor(props) {\n    super(props);\n  }\n\n  createLeafletElement(props) {\n    this.control = L.control.mousePosition().addTo(props.leaflet.map);\n    return this.control;\n  }\n}\n\nexport default withLeaflet(CoordinatesControl);\n","import * as turf from \"@turf/turf\";\nimport PixiOverlay from \"react-leaflet-pixi-overlay\";\nimport { renderToString } from \"react-dom/server\";\nimport React, { useState, useRef, useEffect } from \"react\";\nimport { AsPrimitive } from \"./AsPrimitive\";\nimport { Map, TileLayer, GeoJSON } from \"react-leaflet\";\nimport * as L from \"leaflet\";\nimport \"leaflet/dist/leaflet.css\";\nimport CoordinatesControl from \"./leaflet/CoordinatesControl\";\nimport InputLabel from \"@material-ui/core/InputLabel\";\nimport FormControl from \"@material-ui/core/FormControl\";\nimport Button from \"@material-ui/core/Button\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport Select from \"@material-ui/core/Select\";\n\nconst getCircularReplacer = () => {\n  const seen = new WeakSet();\n  return (key, value) => {\n    if (typeof value === \"object\" && value !== null) {\n      if (seen.has(value)) {\n        return;\n      }\n      seen.add(value);\n    }\n    return value;\n  };\n};\n\nconst shapesFeatureType = [\"LineString\", \"Polygon\", \"MultiPolygon\"];\n\nconst maps = [\n  {\n    name: \"Thunderforest - Landscapes\",\n    attribution: \"Thunderforest and OpenStreetMap contributors.\",\n    url:\n      \"https://{s}.tile.thunderforest.com/landscape/{z}/{x}/{y}{r}.png?apikey=7c352c8ff1244dd8b732e349e0b0fe8d\",\n  },\n  {\n    name: \"Thunderforest - Outdoors\",\n    attribution: \"Thunderforest and OpenStreetMap contributors.\",\n    url:\n      \"https://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}{r}.png?apikey=7c352c8ff1244dd8b732e349e0b0fe8d\",\n  },\n  {\n    name: \"Stamen Design - Toner\",\n    attribution: `Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, under <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a>. Data by <a href=\"http://openstreetmap.org\">OpenStreetMap</a>, under <a href=\"http://www.openstreetmap.org/copyright\">ODbL</a>.`,\n    url: \"https://stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}.png\",\n  },\n  {\n    name: \"Stamen Design - Water color\",\n    url: \"https://stamen-tiles-{s}.a.ssl.fastly.net/watercolor/{z}/{x}/{y}.png\",\n    attribution:\n      'Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a> &mdash; Map data &copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>',\n  },\n  {\n    name: \"Google maps - Satelite\",\n    url: \"http://mt3.google.com/vt/lyrs=s&x={x}&y={y}&z={z}\",\n    attribution: \"Google\",\n  },\n];\n\nconst bboxForPoints = (points) => {\n  const result = [Infinity, Infinity, -Infinity, -Infinity];\n  for (let point of points) {\n    let coord = point.position;\n    if (result[0] > coord[0]) {\n      result[0] = coord[0];\n    }\n    if (result[1] > coord[1]) {\n      result[1] = coord[1];\n    }\n    if (result[2] < coord[0]) {\n      result[2] = coord[0];\n    }\n    if (result[3] < coord[1]) {\n      result[3] = coord[1];\n    }\n  }\n\n  return result;\n};\n\nfunction isString(r) {\n  return typeof r == \"string\";\n}\nfunction getRandomColor() {\n  var letters = \"0123456789ABCDEF\";\n  var color = \"#\";\n  for (var i = 0; i < 6; i++) {\n    color += letters[Math.floor(Math.random() * 16)];\n  }\n  return color;\n}\n\nfunction OrgunitMap({\n  lines,\n  position,\n  showableMap,\n  width,\n  height,\n  showLayers,\n}) {\n  const [status, setStatus] = useState(\"\");\n  const [clicked, setClicked] = useState(\"\");\n  const [selectedLayer, setSelectedLayer] = useState(maps[0]);\n  const [rawPoints, setRawPoints] = React.useState(undefined);\n  const [pointMarkers, setPointMarkers] = React.useState(undefined);\n  const [rawGeojsons, setRawGeojsons] = React.useState(undefined);\n  const mapRef = useRef(null);\n  const handleClick = () => {\n    if (mapRef && mapRef.current) {\n      let bound = undefined;\n      const map = mapRef.current.leafletElement;\n      if (pointMarkers && pointMarkers.length > 0) {\n        const bbox = bboxForPoints(pointMarkers);\n        bound = bbox;\n      }\n\n      if (bound && bound[0] !== Infinity) {\n        const southWest = L.latLng(bound[0], bound[1]);\n        const northEast = L.latLng(bound[2], bound[3]);\n        const bounds = L.latLngBounds(southWest, northEast);\n        map.fitBounds(bounds);\n      } else if (rawGeojsons && rawGeojsons.length > 0) {\n        // I know it looks strange but make debugging easier\n        const myTurf = turf;\n        const functionPoly = myTurf.bbox;\n        // only geojson\n\n        var bboxPolygon;\n        try {\n          bboxPolygon = functionPoly(\n            myTurf.featureCollection(rawGeojsons.map((r) => myTurf.feature(r)))\n          );\n        } catch (e) {\n          debugger;\n          bboxPolygon = functionPoly(rawGeojsons[0]);\n        }\n\n        if (bboxPolygon) {\n          const southWest = L.latLng(bboxPolygon[1], bboxPolygon[0]);\n          const northEast = L.latLng(bboxPolygon[3], bboxPolygon[2]);\n          const bounds = L.latLngBounds(southWest, northEast);\n\n          map.fitBounds(bounds);\n        }\n      }\n    }\n  };\n  useEffect(() => {\n    setTimeout(() => {\n      handleClick();\n    }, 2000);\n  }, [mapRef, pointMarkers, rawGeojsons]);\n\n  useEffect(() => {\n    if (mapRef && mapRef.current && mapRef.current.leafletElement) {\n      const map = mapRef.current.leafletElement;\n      map.on(\"click\", function(event) {\n        let nextTarget = document.getElementsByClassName(\n          \"leaflet-pixi-overlay\"\n        )[0];\n        nextTarget.style.zIndex = -1;\n      });\n      map.on(\n        \"mousemove\",\n        L.Util.throttle(function(event) {\n          if (event.originalEvent) {\n            // get the target pane\n            var currentTarget = event.originalEvent.target;\n            var stopped;\n            var removed;\n            // attempt to grab the next layer below\n            let nextTarget = document.getElementsByClassName(\n              \"leaflet-pixi-overlay\"\n            )[0];\n\n            /*let nextTarget = document.elementFromPoint(\n                event.originalEvent.clientX,\n                event.originalEvent.clientY\n              );*/\n\n            // we keep drilling down until we get stopped,\n            // or we reach the map container itself\n            if (\n              nextTarget &&\n              nextTarget.nodeName.toLowerCase() !== \"body\" &&\n              nextTarget.classList.value.indexOf(\"leaflet-container\") === -1 &&\n              currentTarget !== nextTarget\n            ) {\n              var ev = new MouseEvent(event.type, event.originalEvent);\n              nextTarget.style.zIndex = 1000;\n\n              stopped = !nextTarget.dispatchEvent(ev);\n              if (stopped || ev._stopped) {\n                L.DomEvent.stop(event);\n              }\n            }\n          }\n        }, 32)\n      );\n    }\n  }, [mapRef]);\n  useEffect(() => {\n    if (lines == undefined) {\n      return;\n    }\n    const newRawPoints = lines.filter((l) => {\n      if (l == undefined) {\n        return false;\n      }\n      if (\n        l.coordinates === undefined &&\n        l.coordinate === undefined &&\n        l.geometry === undefined\n      ) {\n        return false;\n      }\n      const isEventCoordinates =\n        l.coordinate && l.coordinate.latitude && l.coordinate.longitude;\n      if (isEventCoordinates) {\n        return true;\n      }\n      if (l.geometry && l.geometry.type == \"Point\") {\n        return true;\n      }\n      if (l.coordinates === undefined) {\n        return false;\n      }\n      return (\n        isString(l.coordinates) &&\n        !l.coordinates.startsWith(\"[[\") &&\n        l.coordinates != \"\"\n      );\n    });\n\n    const newGeojsons = lines\n      .filter(\n        (l) =>\n          (l.coordinates &&\n            isString(l.coordinates) &&\n            l.coordinates.startsWith(\"[[\")) ||\n          (l.geometry &&\n            l.geometry.type &&\n            shapesFeatureType.includes(l.geometry.type))\n      )\n      .map((line) => {\n        let geometry = line.geometry;\n        try {\n          geometry = turf.polygon(JSON.parse(line.coordinates));\n        } catch (ignored) {\n          try {\n            geometry = turf.multiPolygon(JSON.parse(line.coordinates));\n          } catch (ignored) {}\n        }\n        if (geometry) {\n          if (geometry.properties == undefined) {\n            geometry.properties = {};\n          }\n          if (geometry.properties) {\n            geometry.properties.line = line;\n          }\n        }\n        return geometry;\n      })\n      .filter((g) => g);\n\n    const markers = newRawPoints.map((line, index) => {\n      const latlong =\n        line.coordinate && line.coordinate.latitude && line.coordinate.longitude\n          ? [line.coordinate.latitude, line.coordinate.longitude]\n          : line.coordinates\n          ? JSON.parse(line.coordinates).reverse()\n          : line.geometry && line.geometry.coordinates.slice(0).reverse();\n      const color = line.color || \"red\";\n      return {\n        id: \"points\" + index,\n        key: \"points\" + index,\n        iconColor: color,\n        position: latlong,\n        tooltip: () => {\n          return renderToString(\n            <div>\n              {Object.keys(line).map((k) => {\n                return (\n                  <div>\n                    <b>{k}</b> <AsPrimitive value={line[k]} />\n                  </div>\n                );\n              })}\n            </div>\n          );\n        },\n\n        customIcon:\n          '<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"' +\n          color +\n          '\" width=\"5\" height=\"5\" viewBox=\"0 0 5 5\"><circle cx=\"0\" cy=\"0\" r=\"5\" stroke=\"' +\n          color +\n          '\" stroke-width=\"5\" fill=\"' +\n          color +\n          '\" /></svg>',\n      };\n    });\n    setPointMarkers(markers);\n    setRawGeojsons(newGeojsons);\n    setRawPoints(newRawPoints);\n    handleClick();\n  }, [lines]);\n  if (lines == undefined || lines == null) {\n    return <></>;\n  }\n\n  if (!showableMap) {\n    return (\n      <p>\n        Map will show if the lines contains a 'coordinates' or 'geometry' field\n      </p>\n    );\n  }\n\n  function onFeature(feature, event) {\n    if (event.originalEvent._stopped) {\n      return;\n    }\n\n    // get the target pane\n    var currentTarget = event.originalEvent.target;\n    var stopped;\n    var removed;\n\n    // hide the target node\n    removed = {\n      node: currentTarget,\n      pointerEvents: currentTarget.style.pointerEvents,\n    };\n    currentTarget.style.pointerEvents = \"none\";\n\n    // attempt to grab the next layer below\n    let nextTarget = document.elementFromPoint(\n      event.originalEvent.clientX,\n      event.originalEvent.clientY\n    );\n\n    // we keep drilling down until we get stopped,\n    // or we reach the map container itself\n    //nextTarget = mapRef.current.container.children[0].children[2].children[1].children[0]\n    if (\n      nextTarget &&\n      nextTarget.nodeName.toLowerCase() !== \"body\" &&\n      nextTarget.classList.value.indexOf(\"leaflet-container\") === -1\n    ) {\n      var ev = new MouseEvent(event.originalEvent.type, event.originalEvent);\n      stopped = !nextTarget.dispatchEvent(ev);\n      if (stopped || ev._stopped) {\n        L.DomEvent.stop(event);\n      }\n    }\n\n    // restore pointerEvents\n    removed.node.style.pointerEvents = removed.pointerEvents;\n    setClicked(feature);\n  }\n\n  const geojsons =\n    rawGeojsons == undefined\n      ? []\n      : rawGeojsons\n          .filter(\n            (geometry) =>\n              geometry && geometry.properties && geometry.properties.line\n          )\n          .map((geometry, index) => {\n            const line = geometry.properties.line;\n            const opacity = geometry.type == \"LineString\" ? 1 : 0.3;\n            line.fillColor = line.fillColor || getRandomColor();\n            const style = {\n              fillColor: line.fillColor,\n              color: line.color || getRandomColor(),\n              weight: line.opacity || opacity,\n              opacity: line.opacity || opacity,\n              fillOpacity: line.opacity || opacity,\n            };\n            if (clicked == line) {\n              style.weight = 3;\n              style.opacity = 0.8;\n              style.dashArray = \"5,5\";\n            }\n            return (\n              <GeoJSON\n                data={geometry}\n                key={\"parent-\" + index + (clicked == line ? \"clicked\" : \"none\")}\n                style={style}\n                title={JSON.stringify(line, getCircularReplacer())}\n                onClick={(event) => {\n                  onFeature(line, event);\n                }}\n              />\n            );\n          });\n\n  const mapSelected = (event, val) => {\n    setSelectedLayer(val.props.value);\n  };\n\n  return (\n    <div className=\"avoid-page-break\">\n      <p>{status}</p>\n      {showLayers && (\n        <div\n          style={{\n            display: \"flex\",\n          }}\n        >\n          <FormControl>\n            <InputLabel>Layer</InputLabel>\n            <Select onChange={mapSelected} value={selectedLayer}>\n              {maps.map((m) => (\n                <MenuItem value={m}>{m.name}</MenuItem>\n              ))}\n            </Select>\n          </FormControl>\n          <Button onClick={handleClick}>Fit</Button>\n        </div>\n      )}\n      <div>\n        {lines.length} records. {rawPoints ? rawPoints.length : \"?\"} points\n        displayed. {geojsons.length} zones displayed.{\" \"}\n        {clicked &&\n          Object.keys(clicked)\n            .filter((k) => ![\"geometry\", \"coordinates\"].includes(k))\n            .map((k) => {\n              return (\n                <div>\n                  <b>{k}</b> <AsPrimitive value={clicked[k]} />\n                </div>\n              );\n            })}\n      </div>\n\n      {((pointMarkers && pointMarkers[0]) || (geojsons && geojsons[0])) && (\n        <Map\n          preferCanvas={true}\n          doubleClickZoom={false}\n          center={position}\n          zoom={3}\n          ref={mapRef}\n          style={{\n            width: width || \"80%\",\n            height: height || \"900px\",\n            padding: \"0px\",\n          }}\n        >\n          <TileLayer {...selectedLayer}></TileLayer>\n          <CoordinatesControl position=\"top\" coordinates=\"decimal\" />\n\n          {geojsons}\n\n          {pointMarkers && pointMarkers[0] && (\n            <PixiOverlay key=\"4\" markers={pointMarkers} interactive={true} />\n          )}\n        </Map>\n      )}\n    </div>\n  );\n}\n\nexport default OrgunitMap;\n"],"sourceRoot":""}