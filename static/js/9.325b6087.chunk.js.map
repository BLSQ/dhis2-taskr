{"version":3,"sources":["leaflet/CoordinatesControl.js","OrgunitMap.js"],"names":["L","Control","MousePosition","extend","_pos","options","position","separator","emptyString","lngFirst","numDigits","lngFormatter","undefined","latFormatter","formatter","prefix","wrapLng","onAdd","map","this","_container","DomUtil","create","DomEvent","disableClickPropagation","on","_onMouseMove","innerHTML","onRemove","off","getLatLng","e","latlng","wrap","lng","lat","value","prefixAndValue","lngValue","latValue","Util","formatNum","Map","mergeOptions","positionControl","addInitHook","addControl","control","mousePosition","CoordinatesControl","MapControl","constructor","props","super","createLeafletElement","addTo","leaflet","withLeaflet","getCircularReplacer","seen","WeakSet","key","has","add","shapesFeatureType","maps","name","attribution","url","isString","r","getRandomColor","color","i","Math","floor","random","OrgunitMap","lines","showableMap","width","height","showLayers","status","setStatus","useState","clicked","setClicked","selectedLayer","setSelectedLayer","rawPoints","setRawPoints","React","pointMarkers","setPointMarkers","rawGeojsons","setRawGeojsons","mapRef","useRef","handleClick","current","bound","leafletElement","length","points","result","Infinity","point","coord","bboxForPoints","southWest","northEast","bounds","fitBounds","bboxPolygon","functionPoly","turf","type","features","useEffect","setTimeout","event","document","getElementsByClassName","style","zIndex","throttle","originalEvent","currentTarget","target","nextTarget","nodeName","toLowerCase","classList","indexOf","ev","MouseEvent","dispatchEvent","_stopped","stop","newRawPoints","filter","l","coordinates","coordinate","geometry","latitude","longitude","startsWith","newGeojsons","includes","line","JSON","parse","ignored","properties","g","markers","index","latlong","reverse","slice","id","iconColor","tooltip","renderToString","Object","keys","k","AsPrimitive","customIcon","geojsons","opacity","fillColor","weight","fillOpacity","dashArray","GeoJSON","data","title","stringify","onClick","feature","removed","node","pointerEvents","elementFromPoint","clientX","clientY","onFeature","className","display","FormControl","InputLabel","Select","onChange","val","m","MenuItem","Button","preferCanvas","doubleClickZoom","center","zoom","ref","padding","TileLayer","interactive"],"mappings":"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","file":"static/js/9.325b6087.chunk.js","sourcesContent":["import L from \"leaflet\";\nimport { withLeaflet, MapControl } from \"react-leaflet\";\n\nL.Control.MousePosition = L.Control.extend({\n  _pos: null,\n\n  options: {\n    position: \"bottomleft\",\n    separator: \" : \",\n    emptyString: \"Unavailable\",\n    lngFirst: false,\n    numDigits: 5,\n    lngFormatter: undefined,\n    latFormatter: undefined,\n    formatter: undefined,\n    prefix: \"\",\n    wrapLng: true\n  },\n\n  onAdd: function(map) {\n    this._container = L.DomUtil.create(\"div\", \"leaflet-control-mouseposition\");\n    L.DomEvent.disableClickPropagation(this._container);\n    map.on(\"mousemove\", this._onMouseMove, this);\n    this._container.innerHTML = this.options.emptyString;\n    return this._container;\n  },\n\n  onRemove: function(map) {\n    map.off(\"mousemove\", this._onMouseMove);\n  },\n\n  getLatLng: function() {\n    return this._pos;\n  },\n\n  _onMouseMove: function(e) {\n    this._pos = e.latlng.wrap();\n    var lngValue = this.options.wrapLng ? e.latlng.wrap().lng : e.latlng.lng;\n    var latValue = e.latlng.lat;\n    var lng;\n    var lat;\n    var value;\n    var prefixAndValue;\n\n    if (this.options.formatter) {\n      prefixAndValue = this.options.formatter(lngValue, latValue);\n    } else {\n      lng = this.options.lngFormatter\n        ? this.options.lngFormatter(lngValue)\n        : L.Util.formatNum(lngValue, this.options.numDigits);\n      lat = this.options.latFormatter\n        ? this.options.latFormatter(latValue)\n        : L.Util.formatNum(latValue, this.options.numDigits);\n      value = this.options.lngFirst\n        ? lng + this.options.separator + lat\n        : lat + this.options.separator + lng;\n      prefixAndValue = this.options.prefix + \" \" + value;\n    }\n\n    this._container.innerHTML = prefixAndValue;\n  }\n});\n\nL.Map.mergeOptions({\n  positionControl: false\n});\n\nL.Map.addInitHook(function() {\n  if (this.options.positionControl) {\n    this.positionControl = new L.Control.MousePosition();\n    this.addControl(this.positionControl);\n  }\n});\n\nL.control.mousePosition = function(options) {\n  return new L.Control.MousePosition(options);\n};\n\nclass CoordinatesControl extends MapControl {\n  control;\n\n  constructor(props) {\n    super(props);\n  }\n\n  createLeafletElement(props) {\n    this.control = L.control.mousePosition().addTo(props.leaflet.map);\n    return this.control;\n  }\n}\n\nexport default withLeaflet(CoordinatesControl);\n","import * as turf from \"@turf/turf\";\nimport PixiOverlay from \"react-leaflet-pixi-overlay\";\nimport { renderToString } from \"react-dom/server\";\nimport React, { useState, useRef, useEffect } from \"react\";\nimport { AsPrimitive } from \"./AsPrimitive\";\nimport {\n  Map,\n  TileLayer,\n  GeoJSON\n} from \"react-leaflet\";\nimport * as L from \"leaflet\";\nimport \"leaflet/dist/leaflet.css\";\nimport CoordinatesControl from \"./leaflet/CoordinatesControl\";\nimport InputLabel from \"@material-ui/core/InputLabel\";\nimport FormControl from \"@material-ui/core/FormControl\";\nimport Button from \"@material-ui/core/Button\";\nimport MenuItem from \"@material-ui/core/MenuItem\";\nimport Select from \"@material-ui/core/Select\";\n\nconst getCircularReplacer = () => {\n  const seen = new WeakSet();\n  return (key, value) => {\n    if (typeof value === \"object\" && value !== null) {\n      if (seen.has(value)) {\n        return;\n      }\n      seen.add(value);\n    }\n    return value;\n  };\n};\n\nconst shapesFeatureType = [\"LineString\", \"Polygon\", \"MultiPolygon\"];\n\nconst maps = [\n  {\n    name: \"Thunderforest - Landscapes\",\n    attribution: \"Thunderforest and OpenStreetMap contributors.\",\n    url:\n      \"https://{s}.tile.thunderforest.com/landscape/{z}/{x}/{y}{r}.png?apikey=7c352c8ff1244dd8b732e349e0b0fe8d\",\n  },\n  {\n    name: \"Thunderforest - Outdoors\",\n    attribution: \"Thunderforest and OpenStreetMap contributors.\",\n    url:\n      \"https://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}{r}.png?apikey=7c352c8ff1244dd8b732e349e0b0fe8d\",\n  },\n  {\n    name: \"Stamen Design - Toner\",\n    attribution: `Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, under <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a>. Data by <a href=\"http://openstreetmap.org\">OpenStreetMap</a>, under <a href=\"http://www.openstreetmap.org/copyright\">ODbL</a>.`,\n    url: \"https://stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}.png\",\n  },\n  {\n    name: \"Stamen Design - Water color\",\n    url: \"https://stamen-tiles-{s}.a.ssl.fastly.net/watercolor/{z}/{x}/{y}.png\",\n    attribution:\n      'Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a> &mdash; Map data &copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>',\n  },\n  {\n    name: \"Google maps - Satelite\",\n    url: \"http://mt3.google.com/vt/lyrs=s&x={x}&y={y}&z={z}\",\n    attribution: \"Google\",\n  },\n];\n\nconst bboxForPoints = (points) => {\n  const result = [Infinity, Infinity, -Infinity, -Infinity];\n  for (let point of points) {\n    let coord = point.position;\n    if (result[0] > coord[0]) {\n      result[0] = coord[0];\n    }\n    if (result[1] > coord[1]) {\n      result[1] = coord[1];\n    }\n    if (result[2] < coord[0]) {\n      result[2] = coord[0];\n    }\n    if (result[3] < coord[1]) {\n      result[3] = coord[1];\n    }\n  }\n\n  return result;\n};\n\nfunction isString(r) {\n  return typeof r == \"string\";\n}\nfunction getRandomColor() {\n  var letters = \"0123456789ABCDEF\";\n  var color = \"#\";\n  for (var i = 0; i < 6; i++) {\n    color += letters[Math.floor(Math.random() * 16)];\n  }\n  return color;\n}\n\nfunction OrgunitMap({\n  lines,\n  position,\n  showableMap,\n  width,\n  height,\n  showLayers,\n}) {\n  const [status, setStatus] = useState(\"\");\n  const [clicked, setClicked] = useState(\"\");\n  const [selectedLayer, setSelectedLayer] = useState(maps[0]);\n  const [rawPoints, setRawPoints] = React.useState(undefined);\n  const [pointMarkers, setPointMarkers] = React.useState(undefined);\n  const [rawGeojsons, setRawGeojsons] = React.useState(undefined);\n  const mapRef = useRef(null);\n  const handleClick = () => {\n    if (mapRef && mapRef.current) {\n      let bound = undefined;\n      const map = mapRef.current.leafletElement;\n      if (pointMarkers && pointMarkers.length > 0) {\n        const bbox = bboxForPoints(pointMarkers);\n        bound = bbox;\n      }\n\n      if (bound && bound[0] !== Infinity) {\n        const southWest = L.latLng(bound[0], bound[1]);\n        const northEast = L.latLng(bound[2], bound[3]);\n        const bounds = L.latLngBounds(southWest, northEast);\n\n        map.fitBounds(bounds);\n      } else if (rawGeojsons && rawGeojsons.length > 0) {\n        const functionPoly = turf.bbox;\n        // only geojson\n        var bboxPolygon = functionPoly({\n          type: \"FeatureCollection\",\n          features: rawGeojsons,\n        });\n\n        if (bboxPolygon) {\n          const southWest = L.latLng(bboxPolygon[1], bboxPolygon[0]);\n          const northEast = L.latLng(bboxPolygon[3], bboxPolygon[2]);\n          const bounds = L.latLngBounds(southWest, northEast);\n          map.fitBounds(bounds);\n        }\n      }\n    }\n  };\n  useEffect(() => {\n    setTimeout(() => {\n      handleClick();\n    }, 1000);\n  }, [mapRef, pointMarkers]);\n\n  useEffect(() => {\n    if (mapRef && mapRef.current && mapRef.current.leafletElement) {\n      const map = mapRef.current.leafletElement;\n      map.on(\"click\", function(event) {\n        let nextTarget = document.getElementsByClassName(\n          \"leaflet-pixi-overlay\"\n        )[0];\n        nextTarget.style.zIndex = -1;\n      });\n      map.on(\n        \"mousemove\",\n        L.Util.throttle(function(event) {\n          if (event.originalEvent) {\n            // get the target pane\n            var currentTarget = event.originalEvent.target;\n            var stopped;\n            var removed;\n            // attempt to grab the next layer below\n            let nextTarget = document.getElementsByClassName(\n              \"leaflet-pixi-overlay\"\n            )[0];\n\n            /*let nextTarget = document.elementFromPoint(\n                event.originalEvent.clientX,\n                event.originalEvent.clientY\n              );*/\n\n            // we keep drilling down until we get stopped,\n            // or we reach the map container itself\n            if (\n              nextTarget &&\n              nextTarget.nodeName.toLowerCase() !== \"body\" &&\n              nextTarget.classList.value.indexOf(\"leaflet-container\") === -1 &&\n              currentTarget !== nextTarget\n            ) {\n              var ev = new MouseEvent(event.type, event.originalEvent);\n              nextTarget.style.zIndex = 1000;\n\n              stopped = !nextTarget.dispatchEvent(ev);\n              if (stopped || ev._stopped) {\n                L.DomEvent.stop(event);\n              }\n            }\n          }\n        }, 32)\n      );\n    }\n  }, [mapRef]);\n  useEffect(() => {\n    if (lines == undefined) {\n      return;\n    }\n    const newRawPoints = lines.filter((l) => {\n      if (l == undefined) {\n        return false;\n      }\n      if (\n        l.coordinates === undefined &&\n        l.coordinate === undefined &&\n        l.geometry === undefined\n      ) {\n        return false;\n      }\n      const isEventCoordinates =\n        l.coordinate && l.coordinate.latitude && l.coordinate.longitude;\n      if (isEventCoordinates) {\n        return true;\n      }\n      if (l.geometry && l.geometry.type == \"Point\") {\n        return true;\n      }\n      if (l.coordinates === undefined) {\n        return false;\n      }\n      return (\n        isString(l.coordinates) &&\n        !l.coordinates.startsWith(\"[[\") &&\n        l.coordinates != \"\"\n      );\n    });\n\n    const newGeojsons = lines\n      .filter(\n        (l) =>\n          (l.coordinates &&\n            isString(l.coordinates) &&\n            l.coordinates.startsWith(\"[[\")) ||\n          (l.geometry &&\n            l.geometry.type &&\n            shapesFeatureType.includes(l.geometry.type))\n      )\n      .map((line) => {\n        let geometry = line.geometry;\n        try {\n          geometry = turf.polygon(JSON.parse(line.coordinates));\n        } catch (ignored) {\n          try {\n            geometry = turf.multiPolygon(JSON.parse(line.coordinates));\n          } catch (ignored) {}\n        }\n        if (geometry) {\n          if (geometry.properties == undefined) {\n            geometry.properties = {};\n          }\n          if (geometry.properties) {\n            geometry.properties.line = line;\n          }\n        }\n        return geometry;\n      })\n      .filter((g) => g);\n\n    const markers = newRawPoints.map((line, index) => {\n      const latlong =\n        line.coordinate && line.coordinate.latitude && line.coordinate.longitude\n          ? [line.coordinate.latitude, line.coordinate.longitude]\n          : line.coordinates\n          ? JSON.parse(line.coordinates).reverse()\n          : line.geometry && line.geometry.coordinates.slice(0).reverse();\n      const color = line.color || \"red\";\n      return {\n        id: \"points\" + index,\n        iconColor: color,\n        position: latlong,\n        tooltip: () => {\n          return renderToString(\n            <div>\n              {Object.keys(line).map((k) => {\n                return (\n                  <div>\n                    <b>{k}</b> <AsPrimitive value={line[k]} />\n                  </div>\n                );\n              })}\n            </div>\n          );\n        },\n\n        customIcon:\n          '<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"' +\n          color +\n          '\" width=\"5\" height=\"5\" viewBox=\"0 0 5 5\"><circle cx=\"0\" cy=\"0\" r=\"5\" stroke=\"' +\n          color +\n          '\" stroke-width=\"5\" fill=\"' +\n          color +\n          '\" /></svg>',\n      };\n    });\n    setRawGeojsons(newGeojsons);\n    setRawPoints(newRawPoints);\n    setPointMarkers(markers);\n    handleClick();\n  }, [lines]);\n  if (lines == undefined || lines == null) {\n    return <></>;\n  }\n\n  if (!showableMap) {\n    return (\n      <p>\n        Map will show if the lines contains a 'coordinates' or 'geometry' field\n      </p>\n    );\n  }\n\n  function onFeature(feature, event) {\n    if (event.originalEvent._stopped) {\n      return;\n    }\n\n    // get the target pane\n    var currentTarget = event.originalEvent.target;\n    var stopped;\n    var removed;\n\n    // hide the target node\n    removed = {\n      node: currentTarget,\n      pointerEvents: currentTarget.style.pointerEvents,\n    };\n    currentTarget.style.pointerEvents = \"none\";\n\n    // attempt to grab the next layer below\n    let nextTarget = document.elementFromPoint(\n      event.originalEvent.clientX,\n      event.originalEvent.clientY\n    );\n\n    // we keep drilling down until we get stopped,\n    // or we reach the map container itself\n    //nextTarget = mapRef.current.container.children[0].children[2].children[1].children[0]\n    if (\n      nextTarget &&\n      nextTarget.nodeName.toLowerCase() !== \"body\" &&\n      nextTarget.classList.value.indexOf(\"leaflet-container\") === -1\n    ) {\n      var ev = new MouseEvent(event.originalEvent.type, event.originalEvent);\n      stopped = !nextTarget.dispatchEvent(ev);\n      if (stopped || ev._stopped) {\n        L.DomEvent.stop(event);\n      }\n    }\n\n    // restore pointerEvents\n    removed.node.style.pointerEvents = removed.pointerEvents;\n    setClicked(feature);\n  }\n\n  const geojsons =\n    rawGeojsons == undefined\n      ? []\n      : rawGeojsons.filter(geometry => geometry && geometry.properties && geometry.properties.line).map((geometry, index) => {\n          const line = geometry.properties.line;\n          const opacity = geometry.type == \"LineString\" ? 1 : 0.3;\n          line.fillColor = line.fillColor || getRandomColor();\n          const style = {\n            fillColor: line.fillColor,\n            color: line.color || getRandomColor(),\n            weight: line.opacity || opacity,\n            opacity: line.opacity || opacity,\n            fillOpacity: line.opacity || opacity,\n          };\n          if (clicked == line) {\n            style.weight = 3;\n            style.opacity = 0.8;\n            style.dashArray = \"5,5\";\n          }\n          return (\n            <GeoJSON\n              data={geometry}\n              key={\"parent-\" + index + (clicked == line ? \"clicked\" : \"none\")}\n              style={style}\n              title={JSON.stringify(line, getCircularReplacer())}\n              onClick={(event) => {\n                onFeature(line, event);\n              }}\n            />\n          );\n        });\n\n  const mapSelected = (event, val) => {\n    setSelectedLayer(val.props.value);\n  };\n\n  return (\n    <div className=\"avoid-page-break\">\n      <p>{status}</p>\n      {showLayers && (\n        <div\n          style={{\n            display: \"flex\",\n          }}\n        >\n          <FormControl>\n            <InputLabel>Layer</InputLabel>\n            <Select onChange={mapSelected} value={selectedLayer}>\n              {maps.map((m) => (\n                <MenuItem value={m}>{m.name}</MenuItem>\n              ))}\n            </Select>\n          </FormControl>\n          <Button onClick={handleClick}>Fit</Button>\n        </div>\n      )}\n      <div>\n        {lines.length} records. {rawPoints ? rawPoints.length : \"?\"} points\n        displayed. {geojsons.length} zones displayed.{\" \"}\n        {clicked &&\n          Object.keys(clicked)\n            .filter((k) => ![\"geometry\", \"coordinates\"].includes(k))\n            .map((k) => {\n              return (\n                <div>\n                  <b>{k}</b> <AsPrimitive value={clicked[k]} />\n                </div>\n              );\n            })}\n      </div>\n\n      <Map\n        preferCanvas={true}\n        doubleClickZoom={false}\n        center={position}\n        zoom={3}\n        ref={mapRef}\n        style={{\n          width: width || \"80%\",\n          height: height || \"900px\",\n          padding: \"0px\",\n        }}\n      >\n        <TileLayer {...selectedLayer}></TileLayer>\n        <CoordinatesControl position=\"top\" coordinates=\"decimal\" />\n\n        {pointMarkers && (\n          <PixiOverlay markers={pointMarkers} interactive={true} />\n        )}\n        {geojsons}\n      </Map>\n    </div>\n  );\n}\n\nexport default OrgunitMap;\n"],"sourceRoot":""}